# Автомат обрабатывает натуральное число N (0 ≤ N ≤ 255) по следующему алгоритму.
# 1.  Строится восьмибитная двоичная запись числа N.
# 2.  Все цифры двоичной записи заменяются на противоположные (0 на 1, 1 на 0).
# 3.  Полученное число переводится в десятичную запись.
# 4.  Из нового числа вычитается исходное, полученная разность выводится на экран.

# Пример. Дано число N  =  13. Алгоритм работает следующим образом.
# 1.  Восьмибитная двоичная запись числа N: 00001101.
# 2.  Все цифры заменяются на противоположные, новая запись: 11110010.
# 3.  Десятичное значение полученного числа 242.
# 4.  На экран выводится число 242 − 13  =  229.

# Какое число нужно ввести в автомат, чтобы в результате получилось 111?

# 101 = 5         двоичное число
# 00000101 = 5    двоичнчое восьмибитное число

for n in range(0, 256):
  x = bin(n)[2:]
  x = '0' * (8 - len(x)) + x # дописываем слева нули до 8 разрядов
  
  # инвертируем разряды
  x = x.replace('0', '*')
  x = x.replace('1', '0')
  x = x.replace('*', '1')
  
  r = int(x, 2)
  if r - n == 111:
    print(n) 
    break

# ========================================================================

# Автомат получает на вход трёхзначное число. По этому числу строится новое число по следующим правилам.
# 1. Складываются первая и вторая, а также вторая и третья цифры исходного числа.
# 2. Полученные два числа записываются друг за другом в порядке убывания (без разделителей).
# Пример. Исходное число: 348. Суммы: 3+4=7; 4+8=12. Результат: 127.
# Укажите наименьшее число, в результате обработки которого автомат выдаст число 1412.

for n in range(100, 1000):         # Перебираем все трехзначные числа
    x = str(n)                     # Преобразуем число в строку для работы с отдельными цифрами
    
    a = int(x[0])                  # Первая цифра числа
    b = int(x[1])                  # Вторая цифра числа
    c = int(x[2])                  # Третья цифра числа

    sum1 = a + b                   # Сумма первой и второй цифр
    sum2 = b + c                   # Сумма второй и третьей цифр

    # Альтернативное решение:
    # first = str(max(sum1, sum2))  # Большая сумма становится первой частью результата
    # second = str(min(sum1, sum2)) # Меньшая сумма становится второй частью результата
    # s1 = first + second           # Объединяем суммы в порядке убывания
    
    l = [sum1, sum2]               # Создаем список из двух сумм
    l.sort()                       # Сортируем список по возрастанию
    r = str(l[1]) + str(l[0])      # Формируем результат: большая сумма + меньшая сумма
    
    if r == '1412':                # Если результат равен 1412
        print(n)                   # Выводим найденное число
        break                      # Прерываем цикл после нахождения первого подходящего числа

# Ответ: 395


# (альтернативное решение)
for i in range(100, 1000):         # Перебираем все трехзначные числа
    s = str(i)                     # Преобразуем число в строку
    
    k1 = int(s[0]) + int(s[1])     # Сумма первой и второй цифр
    k2 = int(s[1]) + int(s[2])     # Сумма второй и третьей цифр
    
    first = str(max(k1, k2))       # Находим большую сумму
    second = str(min(k1, k2))      # Находим меньшую сумму
    s1 = first + second            # Объединяем суммы в порядке убывания
    
    if s1 == '1412':               # Если результат равен 1412
        print(i)                   # Выводим найденное число
        break                      # Прерываем цикл после нахождения первого подходящего числа

# Ответ: 395

# ========================================================================

# ЗАДАЧА 3
# Автомат получает на вход четырёхзначное число (число не может начинаться с нуля). 
# По этому числу строится новое число по следующим правилам.
# 1. Складываются отдельно первая и вторая, вторая и третья, третья и четвёртая цифры заданного числа.
# 2. Наименьшая из полученных трёх сумм удаляется.
# 3. Оставшиеся две суммы записываются друг за другом в порядке неубывания без разделителей.
# Пример. Исходное число: 1984. Суммы: 1+9=10, 9+8=17, 8+4=12. Удаляется 10. Результат: 1217.
# Укажите наибольшее число, при обработке которого автомат выдаёт результат 613.

for i in range(9999, 1000, -1):    # Перебираем четырехзначные числа от большего к меньшему
    s = str(i)                     # Преобразуем число в строку
    
    k1 = int(s[0]) + int(s[1])     # Сумма первой и второй цифр
    k2 = int(s[1]) + int(s[2])     # Сумма второй и третьей цифр
    k3 = int(s[2]) + int(s[3])     # Сумма третьей и четвертой цифр
    
    l = [k1, k2, k3]               # Создаем список из трех сумм
    l.sort()                       # Сортируем список по возрастанию
    result = str(l[1]) + str(l[2]) # Формируем результат из двух больших сумм (порядок неубывания)
    
    if result == '613':            # Если результат равен 613
        print(i)                   # Выводим найденное число
        break                      # Прерываем цикл после нахождения первого подходящего числа

# Ответ: 9421


# (альтернативное решение)
for i in range(9999, 1000, -1):    # Перебираем четырехзначные числа от большего к меньшему
    s = str(i)                     # Преобразуем число в строку
    
    k1 = int(s[0]) + int(s[1])     # Сумма первой и второй цифр
    k2 = int(s[1]) + int(s[2])     # Сумма второй и третьей цифр
    k3 = int(s[2]) + int(s[3])     # Сумма третьей и четвертой цифр
    
    # Находим среднюю по величине сумму (сумма всех минус максимальная и минимальная)
    first = str(k1 + k2 + k3 - max(k1, k2, k3) - min(k1, k2, k3))
    second = str(max(k1, k2, k3))  # Максимальная сумма
    s1 = first + second            # Объединяем суммы в порядке неубывания
    
    if s1 == '613':                # Если результат равен 613
        print(i)                   # Выводим найденное число
        break                      # Прерываем цикл после нахождения первого подходящего числа

# Ответ: 9421



# ================================================================
#                   ЗАДАЧА 1. «Доступные числа»
# ================================================================
# Условие (кратко):
# 1. На вход алгоритму подаётся натуральное число N.
# 2. Строится двоичная запись числа N (без ведущих нулей).
# 3. Находим остаток от деления N на 4 (N % 4).
# 4. Записываем этот остаток в двоичном виде и дописываем его в КОНЕЦ
#    двоичной записи N.
#    Примеры:
#       N = 13: 13₁₀ = 1101₂, 13 % 4 = 1 → в двоичном виде "1"
#       Получаем строку "1101" + "1" = "11011"₂ = 27₁₀.
#       N = 14: 14₁₀ = 1110₂, 14 % 4 = 2 → в двоичном виде "10"
#       Получаем строку "1110" + "10" = "111010"₂ = 58₁₀.
#
# Числа, которые могут получиться в результате такого преобразования (R),
# называются «доступными».
#
# Вопрос: какое НАИБОЛЬШЕЕ количество доступных чисел может быть на любом
# отрезке, содержащем ровно 65 последовательных натуральных чисел?
#
# Идея решения:
# 1. Перебрать достаточно большой диапазон N (например, от 1 до 999),
#    для каждого N построить R по описанному алгоритму.
# 2. Помечать все полученные R в массиве признаков t:
#       t[r] = 1, если число r доступно (встретилось хотя бы один раз),
#       t[r] = 0, если такое число не встречалось как R.
# 3. Затем "прокатить окно" длиной 65 по массиву t и для каждого
#    отрезка [i, i+64] посчитать, сколько в нём единиц.
#    Это и будет числом доступных R на отрезке длиной 65.
# 4. Взять максимум по всем таким отрезкам — ответ задачи.
#
# Немного теории:
# - Двоичная система счисления: bin(n) в Python возвращает строку
#   вида '0b1101'. Мы отбрасываем первые два символа '0b' с помощью [2:].
# - Остаток от деления N на 4: n % 4 → это число от 0 до 3.
#   В двоичной системе:
#       0 → "0"
#       1 → "1"
#       2 → "10"
#       3 → "11"
#   Мы так же получаем его через bin(n % 4)[2:].
# - Превращение двоичной строки обратно в десятичное число:
#       int(строка_из_0_и_1, 2)
#   например, int("1101", 2) = 13.
#
# - Идея с массивом t:
#   t — это массив длины 10000, изначально t[i] = 0.
#   Если некоторое число r оказалось доступным, мы делаем t[r] = 1.
#   После перебора всех N у нас будет таблица, в которой отмечены все
#   доступные числа R (в пределах диапазона).
#
# - Идея «скользящего окна» длиной 65:
#   Для каждого i считаем sum(t[i : i + 65]) — количество единиц (то есть
#   доступных чисел) на отрезке [i, i+64]. Далее берём максимум по i.
#
#   Это стандартный приём в задачах на «сколько элементов с тем-то
#   свойством можно найти в каждом отрезке фиксированной длины».


t = [0] * 10000      # Создаём список длиной 10000, заполненный нулями.
                     # Индекс — само число R, значение 0 или 1:
                     # 1 — число доступно, 0 — число недоступно.

for n in range(1, 1000):  # Перебираем N от 1 до 999.
    # bin(n) возвращает строку наподобие '0b1101', поэтому [2:]
    # убирает '0b', оставляя только двоичную запись числа.
    s = bin(n)[2:] + bin(n % 4)[2:]
    # Здесь мы реализуем правило алгоритма:
    #   - bin(n)[2:]  — двоичная запись N;
    #   - bin(n % 4)[2:] — двоичный код остатка от деления N на 4;
    #   - оператор + конкатенирует (склеивает) эти строки.

    r = int(s, 2)        # Преобразуем получившуюся двоичную строку s
                         # обратно в десятичное число R с помощью int(..., 2).

    t[r] = 1             # Помечаем число r как «доступное».


print(t)                 # Выводим список t. В нём будут нули и единицы.
                         # На экзамене/ЕГЭ обычно сам список не нужен,
                         # важен только найденный максимум, но здесь
                         # оставляем этот вывод, как в исходном коде.


maxi = 0                 # Переменная для хранения максимума количества
                         # доступных чисел на отрезке длиной 65.

for i in range(1000):    # Сдвигаем окно длиной 65 по первым 1000 позициям.
    # sum(t[i : i + 65]) — количество единиц (доступных чисел) в
    # отрезке чисел от i до i+64 (включительно).
    maxi = max(maxi, sum(t[i: i + 65]))

print(maxi)              # Выводим максимальное количество доступных чисел
                         # на отрезке длиной 65.

# [1, 2, 3, 4, 5, 6]
# Эта строка была в исходном тексте в виде комментария.
# Здесь можно зафиксировать ответ задачи: максимум равен 6,
# а [1, 2, 3, 4, 5, 6] — возможный пример отрезка длины 65,
# содержащего 6 доступных чисел (или просто перечень вариантов ответов
# для нескольких похожих подзадач в источнике условия).


# ================================================================
#         ЗАДАЧА 2. Число единиц и нулей в двоичной записи
# ================================================================
# Условие:
# Алгоритм получает на вход натуральное число N > 1.
# 1. Строится двоичная запись числа N без ведущих нулей.
# 2. Считаем:
#    - количество единиц, стоящих на чётных местах;
#    - и количество нулей, стоящих на нечётных местах.
#    Места считаются слева направо (от старших разрядов к младшим),
#    начиная с 1.
#
#    Например, N = 39:
#    39₁₀ = 100111₂
#
#    Позиции (слева направо):
#    позиция: 1  2  3  4  5  6
#    цифра:   1  0  0  1  1  1
#
#    - На чётных местах (2, 4, 6) — смотрим, сколько там единиц.
#    - На нечётных местах (1, 3, 5) — смотрим, сколько там нулей.
#
# 3. Результат R — это модуль разности:
#       R = |(количество единиц на чётных местах) -
#            (количество нулей на нечётных местах)|
#
# Пример: для N = 39:
#    - единицы на чётных местах: позиции 2, 4, 6 → цифры (0, 1, 1)
#      Здесь две единицы (на позициях 4 и 6).
#    - нули на нечётных местах: позиции 1, 3, 5 → цифры (1, 0, 1)
#      Здесь один ноль (на позиции 3).
#    R = |2 - 1| = 1.
#
# Вопрос: при каком наименьшем N результат алгоритма R будет равен 4?
#
# Идея решения:
# 1. Перебираем все N от 2 до некоторого верхнего предела (здесь 300,
#    этого достаточно, чтобы найти первое подходящее).
# 2. Для каждого N:
#    - строим двоичную запись x = bin(n)[2:];
#    - проходим по всем цифрам, и для каждой определяем её «чётность»
#      позиции (чётная/нечётная), а затем увеличиваем соответствующий
#      счётчик:
#        * единицы на чётных местах,
#        * нули на нечётных местах.
# 3. Если |количество_нулей_на_нечётных - количество_единиц_на_чётных| = 4,
#    выводим N и прекращаем поиск.
#
# Важный момент с индексами в Python:
# - В задаче позиции начинаются с 1 (слева направо).
# - В Python индексация строки начинается с 0 (x[0], x[1], ...).
#   Поэтому:
#     позиция 1 (по условию) → индекс 0 (в Python),
#     позиция 2            → индекс 1,
#     позиция 3            → индекс 2 и т.д.
#
# Значит:
# - чётные позиции (2, 4, 6, ...) соответствуют НЕЧЁТНЫМ индексам (1, 3, 5, ...);
# - нечётные позиции (1, 3, 5, ...) соответствуют ЧЁТНЫМ индексам (0, 2, 4, ...).
#
# В исходном коде это реализовано так:
#   if index % 2 != 0 and value == "1":
#       sum_one += 1
#   elif index % 2 == 0 and value == "0":
#       sum_zero += 1
#
# Пояснение:
#   - index % 2 != 0  → index нечётный → позиция чётная → считаем единицы.
#   - index % 2 == 0  → index чётный → позиция нечётная → считаем нули.
#
# В конце computation для каждого N:
#   if abs(sum_zero - sum_one) == 4:
#       print(n)
#       break
#
# abs(...) — модуль числа, чтобы не зависеть от порядка вычитания.


for n in range(2, 300):   # Перебираем кандидаты N от 2 до 299.
    x = bin(n)[2:]        # Двоичная запись числа N без '0b'.

    sum_one = 0           # sum_one — количество единиц на ЧЁТНЫХ местах
                          # (по условию задачи, места считаются с 1).
    sum_zero = 0          # sum_zero — количество нулей на НЕЧЁТНЫХ местах.

    for index, value in enumerate(x):
        # enumerate(x) возвращает пары (index, value), где:
        #   index — индекс символа в строке x (0, 1, 2, ...),
        #   value — символ '0' или '1'.
        #
        # Напоминание:
        #   - index чётный (0, 2, 4, ...) → позиция нечётная (1, 3, 5, ...).
        #   - index нечётный (1, 3, 5, ...) → позиция чётная (2, 4, 6, ...).

        # 1 1 0 1 1 - исходное число (пример)
        # 0 1 2 3 4 - индексы каждой цифры (в Python)

        if index % 2 != 0 and value == "1":
            # index % 2 != 0 → индекс НЕчётный → позиция ЧЁТНАЯ.
            # А по условию нас интересуют единицы на чётных местах.
            sum_one += 1

        elif index % 2 == 0 and value == "0":
            # index % 2 == 0 → индекс чётный → позиция НЕЧЁТНАЯ.
            # На нечётных местах считаем нули.
            sum_zero += 1

    # После обхода всех разрядов двоичной записи числа N у нас есть:
    #   sum_one  — количество единиц на чётных местах;
    #   sum_zero — количество нулей на нечётных местах.
    #
    # Результат алгоритма R = |sum_zero - sum_one| (модуль разности).
    if abs(sum_zero - sum_one) == 4:
        # Если результат равен 4, мы нашли подходящее N.
        print(n)  # Выводим наименьшее N, т.к. перебор идёт от меньших
        break     # Прерываем цикл, дальше искать не нужно.


# Ниже — вспомогательный пример из исходного кода, оставим его
# в комментариях как мини-демонстрацию работы enumerate и индексов.

# x = '10011'
# #    01234
#
# for index, value in enumerate(x):
#   print(f'под индексом {index} находится значение {value}')
#
# print('\n')
#
# for i in range(len(x)):
#   print(f'под индексом {i} находится значение {x[i]}')

# Этот пример показывает, как enumerate(x) и обычный цикл по индексам
# дают одинаковый результат, но в enumerate сразу доступны и индекс, и символ.

