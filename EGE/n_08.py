from itertools import product

# ==============================================================================
# ЗАДАЧА 1: Кодовый замок (Поиск количества перестановок с условием)
# ==============================================================================
# Шифр кодового замка представляет собой последовательность из пяти символов, 
# каждый из которых является цифрой от 1 до 4. Сколько различных вариантов 
# шифра можно задать, если известно, что цифра 1 встречается ровно два раза, 
# а каждая из других допустимых цифр может встречаться в шифре любое 
# количество раз или не встречаться совсем?

alph = '1234' # Алфавит допустимых символов (цифры от 1 до 4)
l = []        # Список для сохранения подходящих вариантов (можно и просто счетчик использовать)

# product(alph, repeat=5) генерирует все возможные комбинации длиной 5
# Это аналог 5 вложенных циклов for
for i in product(alph, repeat=5):
    # i — это кортеж символов, например ('1', '2', '1', '4', '3')
    
    # Метод .count('1') считает количество единиц в кортеже
    if i.count('1') == 2:
        l.append(i) # Если условие выполнено, добавляем вариант в список

print(f"Задача 1: {len(l)}")


# ==============================================================================
# ЗАДАЧА 2: Четверичная система (Числа и арифметические условия)
# ==============================================================================
# Сколько существует различных трёхзначных чисел, записанных в четверичной 
# системе счисления, в записи которых сумма первой и последней цифры строго 
# больше цифры стоящей по середине?

aplh = '0123' # Алфавит четверичной системы
l = []

# Генерируем все возможные тройки цифр
for i in product(aplh, repeat=3):
    # i[0] — первая цифра, i[1] — вторая, i[2] — третья
    
    # Условие 1: i[0] != '0'. Число не может начинаться с нуля.
    # Условие 2: Сумма крайних > средней.
    # Важно: элементы i — это строки ('0', '1'...), поэтому для математики 
    # их нужно преобразовать в числа через int()
    if (i[0] != '0') and (int(i[0]) + int(i[2]) > int(i[1])):
        l.append(i)

print(f"Задача 2: {len(l)}")


# ==============================================================================
# ЗАДАЧА 3: Семеричная система (Убывающий порядок цифр)
# ==============================================================================
# Сколько существует различных четырёхзначных чисел, записанных в семеричной 
# системе счисления, в записи которых цифры следуют слева направо в строго 
# убывающем порядке?

aplhabet = '0123456' # Алфавит семеричной системы
l = []

# Генерируем 4-значные комбинации
for i in product(aplhabet, repeat=4):
    # Числа должны строго убывать: 1-е > 2-го > 3-го > 4-го.
    # В Python строки сравниваются лексикографически, что для цифр 0-9 
    # совпадает с числовым сравнением (т.е. '5' > '4' дает True).
    # Здесь не нужно проверять i[0] != '0', так как при строгом убывании
    # ноль никогда не окажется на первом месте (меньше нуля в алфавите ничего нет).
    if i[0] > i[1] > i[2] > i[3]:
        l.append(i)

print(f"Задача 3: {len(l)}")


# ==============================================================================
# ЗАДАЧА 4: Слова из букв (Ограничения на буквы)
# ==============================================================================
# Составляют 5-буквенные слова из букв слова ПЯТНИЦА. Найти количество слов, 
# которые не начинаются с Н и в которых есть только одна буква Я. 
# Буквы в слове могут повторяться.

count = 0 # Используем простой счетчик вместо списка

# repeat=5, так как слова 5-буквенные
for i in product('ПЯТНИЦА', repeat=5):
    # i[0] != 'Н' — слово не начинается на Н
    # i.count('Я') == 1 — буква Я встречается ровно один раз
    if i[0] != 'Н' and i.count('Я') == 1:
        count += 1

print(f"Задача 4: {count}")


# ==============================================================================
# ЗАДАЧА 5: Сложное условие ("МАНГУСТ")
# ==============================================================================
# Алиса составляет 6-буквенные слова из букв М, А, Н, Г, У, С, Т. Каждая из 
# букв может встречаться сколько угодно раз, причём первой буквой не может 
# быть А, буква У должна встречаться не менее 1 раза. Также в записи должны 
# быть ровно две буквы М. Сколько различных слов может составить Алиса?

count = 0
for i in product('МАНГУСТ', repeat=6):
    # Комбинируем три условия через логическое И (and):
    # 1. i[0] != 'А' — не начинается на А
    # 2. i.count('У') >= 1 — есть хотя бы одна У
    # 3. i.count('М') == 2 — ровно две буквы М
    if i[0] != 'А' and i.count('У') >= 1 and i.count('М') == 2:
        count += 1

print(f"Задача 5: {count}")


# ==============================================================================
# ЗАДАЧА 6: Алфавитный порядок и нумерация слов
# ==============================================================================
# Все 5-буквенные слова, в составе которых могут быть буквы А, Л, Г, О, Р, И, Т, М, 
# записаны в алфавитном порядке и пронумерованы начиная с 1.
# ...
# Определите в этом списке количество слов с нечетными номерами, которые не 
# начинаются с буквы Г и при этом содержат в своей записи не менее двух букв И.

count = 0  # Количество подходящих слов
number = 1 # Номер текущего слова в списке (начинается с 1)

# ВАЖНО: Для задач с порядком слов алфавит ОБЯЗАТЕЛЬНО нужно сортировать.
# sorted('АГИЛМОРТ') гарантирует, что перебор пойдет: ААААА, ААААГ, ААААИ...
for i in product(sorted('АГИЛМОРТ'), repeat=5):
    
    # number % 2 != 0 — проверяем, что номер слова нечетный
    # i[0] != 'Г' — не начинается на Г
    # i.count('И') >= 2 — содержит 2 или более букв И
    if number % 2 != 0 and i[0] != 'Г' and i.count('И') >= 2:
        count += 1
    
    number += 1 # Увеличиваем номер слова на каждой итерации цикла
  
print(f"Задача 6: {count}")


# ==============================================================================
# ЗАДАЧА 7: Девятеричная система и запрещенные пары ("Соседи")
# ==============================================================================
# Игорь составляет пятизначные числа, используя цифры девятеричной системы 
# счисления. Сколько различных чисел может составить Игорь, в которых только 
# одна цифра 5 и рядом с ней НЕ стоят нечётные цифры?

count = 0

# Список запрещенных пар. В 9-ичной системе (0..8) нечетные цифры: 1, 3, 5, 7.
# Так как '5' у нас всего одна, она не может стоять рядом с другой '5'.
# Значит, запрещены пары '5' с '1', '3', '7'.
# Проверяем как '5' слева от нечетной, так и '5' справа от нечетной.
t = ['51','53', '57', '15', '35', '75']

for i in product('012345678', repeat=5):
    p = ''.join(i) # Склеиваем кортеж в строку для удобного поиска подстрок
    
    # 1. p[0] != '0' — число не начинается с нуля
    # 2. p.count('5') == 1 — ровно одна пятерка
    # 3. all(not x in p for x in t) — ни одна пара из списка t не содержится в числе p
    # (переменная цикла в all названа x, чтобы не путать с i из product)
    if p[0] != '0' and p.count('5') == 1 and all(not x in p for x in t):
        count += 1

print(f"Задача 7: {count}")

# all(...) — это встроенная функция Python, которая проверяет, что все элементы итерируемого объекта истинны (то есть дают True).

# Базовая идея
# all([True, True, True]) → True

# all([True, False, True]) → False

# all([]) → True (важный нюанс: “для пустого набора нет контрпримеров”, поэтому считается истинным)

# То есть all работает как логическое “И” по списку условий.

# Как all работает в задаче 7
# Фрагмент: all(not x in p for x in t)
# Здесь:
# t = ['51','53','57','15','35','75'] — список запрещённых соседних пар

# p — строка из 5 цифр, например "20458"

# Выражение внутри all — это генератор:

# (not x in p for x in t)
# Он по очереди подставляет каждую строку x из списка t и проверяет:

# есть ли подстрока x в строке p

# затем делает отрицание not

# То есть для каждого x получается условие:

# not ('51' in p)

# not ('53' in p)

# ...

# not ('75' in p)

# А all(...) требует, чтобы все эти условия были истинны. Иначе говоря: “в числе не встречается ни одна запрещённая пара”.

# Маленький пример “вручную”
# Пусть:

# p = "20578"

# Проверяем пары из t:

# '51' in p → False, значит not False → True

# '53' in p → False → True

# '57' in p → True (в строке есть "57"), значит not True → False

# Как только появляется False, итог:

# all(...) → False
# И число не подходит, потому что рядом с 5 стоит нечётная 7.

# Важное свойство: “короткое замыкание”
# all не обязан проверять всё до конца. Он работает так:

# встретил False → сразу возвращает False и прекращает проверки

# Это ускоряет перебор, потому что плохие варианты отсеиваются быстрее.

# Эквивалент без all (чтобы было совсем понятно)
# Вот то же самое, но “обычным кодом”:

# python
# ok = True
# for x in t:
#     if x in p:      # нашли запрещённую пару
#         ok = False
#         break       # дальше проверять смысла нет

# if ok:
#     count += 1
# То есть all(not x in p for x in t) — это компактная форма проверки “ни одной запрещённой подстроки нет”.
